"""Strategy models for access pathway selection."""
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any, Literal
from uuid import uuid4

from pydantic import BaseModel, Field

from .enums import StrategyType


class AppealStrategy(BaseModel):
    """
    Clinical appeal strategy generated by Claude PA Skill.
    Used as input to LLM Gateway for appeal letter drafting.

    This separates clinical reasoning (Claude) from letter formatting (Gemini/GPT)
    for auditability of the clinical logic.
    """
    appeal_strategy_id: str = Field(default_factory=lambda: str(uuid4()))
    case_id: str = Field(..., description="Case this appeal is for")
    payer_name: str = Field(..., description="Payer being appealed")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    # Denial context
    denial_reason_code: str = Field(..., description="Denial reason code")
    denial_reason_text: str = Field(..., description="Full denial text")
    denial_classification: Literal[
        "medical_necessity", "documentation_incomplete",
        "step_therapy", "prior_auth_expired", "not_covered", "other"
    ] = Field(..., description="Classification of denial type")

    # Clinical arguments (generated by Claude)
    primary_clinical_argument: str = Field(
        ...,
        description="Primary clinical argument for medical necessity"
    )
    supporting_arguments: List[str] = Field(
        default_factory=list,
        description="Supporting clinical arguments"
    )
    evidence_to_cite: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Specific evidence to reference"
    )
    policy_sections_to_reference: List[str] = Field(
        default_factory=list,
        description="Policy sections supporting the appeal"
    )
    medical_literature_citations: List[str] = Field(
        default_factory=list,
        description="Medical literature to cite"
    )

    # Recommended approach
    recommended_appeal_type: Literal["standard", "expedited", "peer_to_peer"] = Field(
        ...,
        description="Recommended type of appeal"
    )
    urgency_justification: Optional[str] = Field(
        default=None,
        description="Justification for expedited appeal if recommended"
    )
    peer_to_peer_talking_points: Optional[List[str]] = Field(
        default=None,
        description="Key points for peer-to-peer review"
    )

    # Confidence and risk
    success_probability: float = Field(
        ..., ge=0.0, le=1.0,
        description="Estimated probability of appeal success"
    )
    success_probability_reasoning: str = Field(
        ...,
        description="Reasoning for success probability"
    )
    key_risks: List[str] = Field(
        default_factory=list,
        description="Key risks in the appeal"
    )

    # Fallback options
    fallback_strategies: List[str] = Field(
        default_factory=list,
        description="Alternative approaches if appeal fails"
    )


class CounterfactualAnalysis(BaseModel):
    """
    What-if analysis showing alternative outcomes.
    Key differentiator for agentic reasoning.
    """
    analysis_id: str = Field(default_factory=lambda: str(uuid4()))
    case_id: str = Field(..., description="Case being analyzed")
    selected_strategy_id: str = Field(..., description="Actually selected strategy")
    analyzed_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    # Alternative outcomes
    alternatives: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="List of alternative strategies with projected outcomes"
    )

    # Key insights
    key_tradeoffs: List[str] = Field(
        default_factory=list,
        description="Key tradeoffs between strategies"
    )
    selection_rationale: str = Field(
        ...,
        description="Why the selected strategy was chosen"
    )
    what_would_change: Dict[str, str] = Field(
        default_factory=dict,
        description="What would need to change for alternatives to be preferred"
    )


class RecoveryStrategy(BaseModel):
    """
    Strategy for recovering from a denial or setback.
    Generated when original plan encounters obstacles.
    """
    recovery_strategy_id: str = Field(default_factory=lambda: str(uuid4()))
    case_id: str = Field(..., description="Case this recovery is for")
    payer_name: str = Field(..., description="Payer with the issue")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    # Root cause
    failure_type: Literal[
        "denial", "missing_docs", "timeout", "info_request", "technical_error"
    ] = Field(..., description="Type of failure requiring recovery")
    root_cause_analysis: str = Field(..., description="Analysis of what went wrong")
    linked_to_intake_gap: Optional[str] = Field(
        default=None,
        description="Gap identified at intake that caused this"
    )

    # Recovery options (scored)
    recovery_options: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Possible recovery paths with scores"
    )
    selected_option: str = Field(..., description="Selected recovery approach")
    selection_reasoning: str = Field(..., description="Why this option was selected")

    # Execution plan
    recovery_actions: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Actions to execute for recovery"
    )
    deadline_tracking: Dict[str, datetime] = Field(
        default_factory=dict,
        description="Key deadlines (appeal, resubmission)"
    )

    # Parallel execution
    parallel_actions: bool = Field(
        default=False,
        description="Whether to run actions in parallel"
    )
    escalation_trigger: Optional[str] = Field(
        default=None,
        description="Condition that triggers human escalation"
    )


@dataclass
class ScoringWeights:
    """Weights for strategy scoring algorithm."""
    speed: float = 0.30  # Weight for time to decision
    approval: float = 0.40  # Weight for approval probability
    low_rework: float = 0.20  # Weight for minimizing rework
    patient_burden: float = 0.10  # Weight for patient convenience

    def validate(self) -> bool:
        """Validate weights sum to 1.0."""
        total = self.speed + self.approval + self.low_rework + self.patient_burden
        return abs(total - 1.0) < 0.001


class StrategyStep(BaseModel):
    """A single step in an access strategy."""
    step_number: int = Field(..., description="Order of this step")
    action_type: str = Field(..., description="Type of action to take")
    target_payer: Optional[str] = Field(default=None, description="Payer this step targets")
    description: str = Field(..., description="Description of the step")
    dependencies: List[int] = Field(default_factory=list, description="Step numbers this depends on")
    estimated_duration_hours: int = Field(default=24, description="Estimated time to complete")
    success_criteria: str = Field(..., description="What defines success for this step")


class Strategy(BaseModel):
    """An access strategy for obtaining prior authorization."""
    strategy_id: str = Field(default_factory=lambda: str(uuid4()))
    strategy_type: StrategyType = Field(..., description="Type of strategy")
    name: str = Field(..., description="Human-readable strategy name")
    description: str = Field(..., description="Detailed description of the strategy")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    # Payer sequence
    payer_sequence: List[str] = Field(..., description="Order of payers to approach")
    parallel_submission: bool = Field(default=False, description="Whether to submit in parallel")

    # Steps
    steps: List[StrategyStep] = Field(default_factory=list, description="Ordered steps to execute")

    # Base scores (before case-specific adjustment)
    base_speed_score: float = Field(..., ge=0.0, le=10.0, description="Speed score (0-10)")
    base_approval_score: float = Field(..., ge=0.0, le=10.0, description="Base approval score")
    base_rework_risk: float = Field(..., ge=0.0, le=10.0, description="Rework risk (0-10, lower is better)")
    base_patient_burden: float = Field(..., ge=0.0, le=10.0, description="Patient burden (0-10, lower is better)")

    # Rationale
    rationale: str = Field(..., description="Why this strategy might be optimal")
    risk_factors: List[str] = Field(default_factory=list, description="Potential risks with this strategy")
    mitigation_strategies: List[str] = Field(default_factory=list, description="How to mitigate risks")


class StrategyScore(BaseModel):
    """Calculated score for a strategy applied to a specific case."""
    strategy_id: str = Field(..., description="ID of the strategy being scored")
    case_id: str = Field(..., description="ID of the case")
    scored_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    # Component scores (adjusted for case)
    speed_score: float = Field(..., ge=0.0, le=10.0)
    approval_score: float = Field(..., ge=0.0, le=10.0)
    rework_score: float = Field(..., ge=0.0, le=10.0)  # 10 - rework_risk
    patient_score: float = Field(..., ge=0.0, le=10.0)  # 10 - patient_burden

    # Adjustments applied
    adjustments: Dict[str, float] = Field(default_factory=dict, description="Score adjustments applied")
    adjustment_reasoning: List[str] = Field(default_factory=list, description="Reasons for adjustments")

    # Final score
    total_score: float = Field(..., ge=0.0, le=10.0, description="Weighted total score")
    weights_used: Dict[str, float] = Field(default_factory=dict, description="Weights used for scoring")

    # Comparison
    rank: int = Field(default=0, description="Rank among all strategies")
    is_recommended: bool = Field(default=False, description="Whether this is the recommended strategy")
    recommendation_reasoning: Optional[str] = Field(default=None, description="Why this is/isn't recommended")


# Pre-defined strategy templates
# IMPORTANT: Only sequential primary-first strategies are valid for PA submissions
# - Never submit in parallel (causes COB coordination issues)
# - Never submit to secondary before primary (violates insurance rules)
STRATEGY_TEMPLATES = {
    StrategyType.SEQUENTIAL_PRIMARY_FIRST: {
        "name": "Sequential (Primary First)",
        "description": "Submit to primary insurance first, then coordinate with secondary after primary decision. This is the standard and only valid approach for PA submissions.",
        "payer_sequence": ["PRIMARY", "SECONDARY"],  # Will be replaced with actual payer names at runtime
        "parallel_submission": False,
        "base_speed_score": 6.0,
        "base_approval_score": 7.0,
        "base_rework_risk": 3.0,
        "base_patient_burden": 4.0,
        "rationale": "Industry-standard approach following proper primary/secondary order. Ensures proper Coordination of Benefits (COB) and avoids claim coordination issues.",
        "risk_factors": ["Extended timeline if primary denies and appeal is needed"],
        "mitigation_strategies": [
            "Prepare appeal materials proactively during primary review",
            "Track all deadlines carefully",
            "Communicate timeline expectations to patient",
            "Document all interactions for secondary coordination"
        ],
    },
}
